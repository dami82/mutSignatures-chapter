---
title: "Mutational Signature Analysis using mutSignatures"
author: "Damiano Fantini"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "asis", fig.align = "center", 
                      fig.width = 8, fig.height = 5, comment = '#', message = FALSE, 
                      warning = FALSE, fig.keep = "last")

# Load libs
#
library(mutSignatures)
library(dplyr)
library(ggplot2)
library(BSgenome.Hsapiens.UCSC.hg19)
library(kableExtra)

# Set working dir
#
#setwd('~/mutSignatures_chapter/03_method/')
```


## The mutSignatures R pipeline

One of the hallmarks of cancer is the accumulation of somatic mutations. 
Exposure to carcinogens, DNA damage and 
inaccurate DNA repair may drive the formation of characteristic 
non-random patterns of DNA mutations, which are also known as 
**mutational signatures**.

There are several bioinformatic pipelines that allow analysis of mutational 
signatures. Here, we use the 
`mutSignatures` R library to perform such analysis. This library
was described in 
[Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0) 
and is available on *CRAN*, and on *GitHub* at the following URL:
<https://github.com/dami82/mutSignatures>. You can install the latest version 
(at this time, ver `2.1.5`) of the library in your R environment using 
the `devtools` R package and via the following line:

```
devtools::install_github("dami82/mutSignatures", force = TRUE, build_vignettes = TRUE)
```

Additional documentation to help getting started with the `mutSignatures` 
R library is available online ([CRAN vignette](https://cran.r-project.org/web/packages/mutSignatures/vignettes/get_sarted_with_mutSignatures.html); 
[Website](http://www.mutsignatures.org/); 
[Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0) and 
[corresponding Supplementary Materials](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7589488/bin/41598_2020_75062_MOESM1_ESM.pdf)).


-----

## Goal of the vignette

The goal of this vignette is to document all steps of a typical 
mutational signatures analysis performed using `mutSignatures`. 
A list of bladder cancer (BLCA) derived VCF files 
is used as input. These VCF files were generated
using unrestricted publicly available TCGA BLCA 
data ([input TCGA MAF available here](https://gdac.broadinstitute.org/runs/analyses__2016_01_28/reports/cancer/BRCA-TP/MutSigNozzleReport2CV/BRCA-TP.final_analysis_set.maf): data were downloaded, pre-processed, re-foprmatted, 
and exploded into donor-specific VCF files as described here:
[GitHub mutSignatures-chapter Repo / build input files](https://github.com/dami82/mutSignatures-chapter/tree/main/02_build_input_files).



The steps covered in the vignette include: 


1. Data import from bladder cancer VCF files and data pre-processing

2. *De novo* extraction of mutational signatures

3. Deconvolution of mutation data using previously identified mutational signatures

4. Results, visualization and data export


This vignette also includes additional notes and examples, focused on:

1.

1. Selection of a suitable number of signatures to extract

2. Advanced visualizations

3. ddd





-----

### Acknowledgements

Joshua J Meeks (<joshua.meeks@northwestern.edu>), xyz (<xyz@northwestern.edu >).

-----


## Preparing the R environment, obtaining VCF files

This vignette is built using `R version 4.2.1` running under 
`Ubuntu 20.04.4 LTS`. The following R libraries are required: 
`mutSignatures`, `dplyr`, `ggplot2`, `BSgenome.Hsapiens.UCSC.hg19`, 
`httr`, and `kableExtra`.

VCF files (`*.vcf.gz`) were downloaded from the following GitHub repo:
<https://github.com/dami82/mutSignatures-chapter>. Contents of the 
`02_build_input_files/VCF_de_novo` and `02_build_input_files/VCF_deconv` 
folders were read using the `httr` R library. 
The folder structure was re-created locally. 
These VCF files are used throughout the analysis 
for extracting and attributing mutational signatures. 


```{r results='markup', comment='#', message=FALSE}
# Load libs
library(mutSignatures)
library(dplyr)
library(ggplot2)
library(BSgenome.Hsapiens.UCSC.hg19)
library(kableExtra)

# GitHub URL, repo and subfolders
gh_raw_url <- 'https://github.com/dami82/mutSignatures-chapter/raw/main/'
gh_repo_url <- 'https://github.com/dami82/mutSignatures-chapter/tree/main/02_build_input_files/'
sub_fld_1 <- 'VCF_de_novo'
sub_fld_2 <- 'VCF_deconv'

# Initialize subfolders
try(unlink(sub_fld_1, recursive = TRUE), silent = TRUE)
dir.create(sub_fld_1)

try(unlink(sub_fld_2, recursive = TRUE), silent = TRUE)
dir.create(sub_fld_2)

# Read and download VCF files in sub_fld_1
tmp_req <- httr::GET(paste0(gh_repo_url, sub_fld_1))
tmp_cnt <- httr::content(req, as = 'parsed')
for (i in 1:length(tmp_cnt)) {
  
  try(download.file(url = paste0(gh_raw_url, tmp_cnt[[i]]$path), 
                    destfile = paste0(sub_fld_1, '/', tmp_cnt[[i]]$name)), 
      silent = TRUE)
}

# Read and download VCF files in sub_fld_2
tmp_req <- httr::GET(paste0(gh_base_url, gh_repo_url, sub_fld_2))
tmp_cnt <- httr::content(req, as = 'parsed')
for (i in 1:length(tmp_cnt)) {
  
  try(download.file(url = paste0(gh_raw_url, tmp_cnt[[i]]$path), 
                    destfile = paste0(sub_fld_2, '/', tmp_cnt[[i]]$name)), 
      silent = TRUE)
}
```


-----



## Implementation


### 1. Data import from bladder cancer VCF files and data pre-processing


Data import and pre-processing is the first phase of this analysis. 
Often, mutation data are stored in **Variant Call Format (VCF)** 
files (for more info about the VCF specifications, 
see <http://samtools.github.io/hts-specs/>). The VCF data parsing and 
pre-processing involves 6 steps:  

1. VCF file data are parsed via the `importVCFfiles()` function, which returns an aggregated `data.frame`. 

2. The `filterSNV()` function removes INDELS and non-SNV mutations from the `data.frame`. 

3. Additional filtering and editing (optional). The user may want to remove variants with low Phred scores or edit *seqNames* (*i.e.,* chromosome names) or sample identifiers as needed.

4. Using the appropriate Reference `BSgenome` object, the `attachContext()` function retrieves the 3-nucleotide context at each SNV genomic position. 

5. The `removeMismatchMut()` function applies a final filter where SNVs are removed if mismatches are detected between expected and observed (reference) DNA sequences.  

6. Mutation types (*mutTypes*) are then computed for each SNV following the format proposed by the Sanger Institute (with pyrimidines as reference base) via the `attachMutType()` function.


The code shown below illustrates how to execute all data import and pre-processing steps.

```{r results='markup', comment='#'}
# import mutation data from a list of VCF files
vcf_ext <- 'vcf.gz'
de_novo_fld <- 'VCF_de_novo/'
my_vcfs <- grep(pattern = vcf_ext, dir(de_novo_fld), value = TRUE)
my_vcfs <- paste0(de_novo_fld, my_vcfs)
head(my_vcfs)
# Read a list of VCF files via importVCFfiles()
x <- importVCFfiles(vcfFiles = my_vcfs)

# Check data.frame dims
dim(x)
# Remove INDELS and non-SNV mutations
x <- filterSNV(dataSet = x,                     # input data.frame  
               seq_colNames = c("REF", "ALT"))  # columns w/ sequence data

# Check data.frame dims
dim(x)
# Optional filtering & editing
# (Recommendation) Use `dplyr`
x <- x %>%
  dplyr::filter(QUAL >= 10) 

# Check data.frame dims
dim(x)
# Attach 3-nt context
hg19 <- BSgenome.Hsapiens.UCSC.hg19
x <- attachContext(mutData = x,                  # input data.frame
                   BSGenomeDb = hg19,            # Reference Genome object
                   chr_colName = 'CHROM',        # seqNames column
                   start_colName = 'POS',        # genomic position column
                   end_colName = 'POS',          # for VCF files, same as above
                   nucl_contextN = 3,            # how large shall the context be
                   context_colName = 'context')  # name of the column being added

# Check data.frame dims
dim(x)
# Remove mismatches (positions whose VCF reference does not match the 
# corresponding genome sequence)
x <- removeMismatchMut(mutData = x,                  # input data.frame
                       refMut_colName = "REF",       # column name for ref base
                       context_colName = "context",  # column name for context
                       refMut_format = "N")          # reference format ('N')  

# Check data.frame dims
dim(x)
# Compute mutType (according to the standards proposed by the Sanger 
# Institute, i.e. with pyrimidines as reference base)
x <- attachMutType(mutData = x,                      # as above
                   ref_colName = "REF",              # column name for ref base
                   var_colName = "ALT",              # column name for mut base
                   context_colName = "context")      # context colname 

# Check data.frame dims
dim(x)
```


At the end of pre-processing phase, we obtain a `data.frame` where each row 
corresponds to a mutation. The `data.frame` includes two columns which are important 
for the downstream analyses: **1)** a column with sample identifiers 
(here, `SAMPLEID`); and **2)** a column with 
3-nucleotide mutation types (here, `mutType`). An excerpt of the `data.frame`
is shown below.


```{r results='asis'}
# Visualize head of the resulting data.frame
x %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 9, full_width = FALSE)
```


-----


### 2. *De novo* extraction of mutational signatures {#section_de_novo}


A *de novo* extraction of mutational signatures means performing 
non-negative matrix factorization (NMF) to identify patterns that can 
explain the distribution of somatic mutations observed across cancer samples. 

The `mutSignatures` R library supports Brunet's algorithm for NMF 
(described by [Brunet JP et al, 2004](https://doi.org/10.1073/pnas.0308531101)) 
as well as an alternative NMF algorithm (for more info see  
[Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0)).

A *de novo* extraction of mutational signatures involves 3 steps: 

1. count mutation types with respect to samples 
(via the `countMutTypes()` function and starting from the `data.frame` 
we prepared earlier as input)

2. define a list of parameters for the analysis, including the number of signatures to 
extract, number of bootstrapping iteration, and number of cores to use 
(parallelization, optional)

3. perform NMF with bootstrapping via the `decipherMutationalProcesses()` function


The latter step can take several minutes / hours to complete, 
depending on the compute resources (amount of memory and number of cores), 
the size of the dataset and the complexity of the problem.


In this example, we extract `k=5` mutational signatures 
and perform 500 bootstrap iterations using the collection 
of somatic mutations compiled from the bladder cancer VCF data as input.

```{r results='markup', comment='#'}
# Count 3-nucleotide mutation types
blca_counts <- countMutTypes(mutTable = x, 
                             mutType_colName = 'mutType', 
                             sample_colName = 'SAMPLEID')

# Output
blca_counts
# Define parameters for the non-negative matrix factorization procedure.
blca_params <- setMutClusterParams( 
    num_processesToExtract = 5,       # num signatures to extract
    num_totIterations = 20,           # bootstrapping: usually 500-1000
    num_parallelCores = 1,            # num of cores (parallelization)
    seed = 12345)                     # random seed (optional) 
```

```{r results='asis'}
# De Novo Extraction of Mutational Signatures (may take a while)
blca_analysis <- decipherMutationalProcesses(input = blca_counts,
                                             params = blca_params)
```

*Silhouette plot showing robustness of the mutational signatures returned by the NMF analysis with bootstrapping.*


-----


Results (and intermediates) of a *de novo* signature extraction job are returned 
as elements of a `list` object. Specifically, output includes: 

- Mutational signatures: `[['Results']][['signatures']]` element 
(`mutationSignatures` object).

- Signature exposures (*i.e.* signature activities): 
`[['Results']][['exposures']]` element (`mutSignExposures` object).


These objects are further discussed in [section 4](#section_viz).


```{r results='markup'}
de_novo_sigs <- blca_analysis$Results$signatures
de_novo_activities <- blca_analysis$Results$exposures

# Show Signatures Object (output - I)
de_novo_sigs
```


-----




### 3. Deconvolution of mutation data using previously identified mutational signatures {#section_deconv}


The `mutSignatures` library also supports 
deconvolution of mutation data using previously identified mutational signatures 
(*e.g.,* COSMIC signatures or signatures that were 
identified as discussed in the section above).

The contribution (activity) of different mutational signatures in each sample 
is estimated via a fast combinatorial non-negative least-square
algorithm. This analysis is typically very fast, 
does not require parallelization, and
is carried out via the `resolveMutSignatures()` function. 

This type of analysis entails 3 steps: 

1. count mutation types with respect to samples 
(via the `countMutTypes()` function and starting from the `data.frame` 
we prepared earlier as input)

2. retrieve a set of mutational signatures (`mutationSignatures` object)

3. resolve mutational signature activities via the 
`resolveMutSignatures()` function



In this example, we retrieve COSMIC signatures (version 2), 
subset bladder-related COSMIC signatures (*i.e.*, COSMIC-1, -2, -5, -13; 
see <https://doi.org/10.1038/nature12477>) 
and assign signature activities using the same collection 
of bladder cancer somatic mutations that were 
also used in the previous example.


```{r results='markup'}
# Count 3-nucleotide mutation types
blca_counts <- countMutTypes(mutTable = x, 
                             mutType_colName = 'mutType', 
                             sample_colName = 'SAMPLEID')

# Output
blca_counts
# Retrieve COSMIC signatures.
all_cosmic_v2 <- getCosmicSignatures()
blca_cosmic <- all_cosmic_v2[c(1, 2, 5, 13)]

# Output
blca_cosmic
# Resolve signature activities
blca_activ_analysis <- resolveMutSignatures(mutCountData = blca_counts, 
                                            signFreqData = blca_cosmic)
```




Results (and intermediates) of a signature activity attribution job are returned 
as elements of a `list` object.  Specifically, output includes: 

- Signature exposures (*i.e.* signature activities): 
`[['Results']][['count.result']]` element (`mutSignExposures` object).


This class of objects is further discussed in section 4.

```{r}
# Results
deconv_actv <- blca_activ_analysis$Results$count.result

# Show object
deconv_actv
```


-----




### 4. Results, visualization and data export {#section_viz}


**Visualize mutational signatures**


We can inspect the mutation profile of individual mutational
signatures that are included in a `mutationSignatures` object.
Examples include results of *de novo* extraction jobs (as shown above in 
[section 2](#section_de_novo)) or COSMIC signatures retrieved 
via the `getCosmicSignatures()` 
function (as shown above in [section 3](#section_deconv)).

The `msigPlot()` method can automatically build a barplot representing the
mutation profile of a signature of interest. The `signature` argument is used
to specify the numeric index of the signature of interest. Additional arguments 
(optional) are passed to the `plotMutTypeProfile()` function.

An example is shown below (using results from our the *de novo* signature 
extraction analysis).


```{r results='asis', fig.height=3.2, fig.width=12}
msigPlot(de_novo_sigs, signature = 2, ylim = c(0, 0.16), 
         main = 'BLCA signature (de novo) - #2')
```

*Barplot summarizing a mutational signature profile. Each bar indicates the frequency (y-axis) of a certain mutation type (x-axis) in the signature. Values are winsorized at 0.16 and 3-nucleotide mutation types are grouped and colored according to the corresponding SNV.*

-----


**Export mutationSignatures objects to `data.frame`**

A `mutationSignatures` object can be easily exported to `data.frame` using
either the `mutSignatures::as.data.frame()` method or the `coerceObj()` 
function. Each row is a mutation type, each colum is a signature. Values 
indicate the frequency of each mutation type in each mutation signature.
An example is shown below.


```{r results='asis'}
# Convert to data.frame
sigs_df <- mutSignatures::as.data.frame(de_novo_sigs)

# Show excerpt
sigs_df %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 9, full_width = FALSE)
```


-----

**Compare mutational signatures**

It is possible to perform a pairwise comparison across mutational signatures 
included in two `mutationSignatures` objects via the `matchSignatures()` 
function. 
Here we compare n=5 *de novo* extracted signatures from the bladder cancer 
samples to the n=4 COSMIC signatures previoulsy reported as prelavent in 
bladder cancer (COSMIC-1, -2, -5, -13). Results are visualized via a
heatmap chart where color intensity tracks with similarity (computed as 
`1 - cosine_distance`).

The plot shows that all but one of the n=5 *de novo* extracted signatures 
matched a corresponding BLCA COSMIC signature.


```{r results='asis', fig.height=4.5, fig.width=5.5}
# Match signatures
blca_new_vs_cosmic <- matchSignatures(de_novo_sigs, blca_cosmic)

# Show heatmap
blca_new_vs_cosmic$plot
```

*Heatmap showing similarity between bladder cancer de novo-extracted mutational signatures and n=4 COSMIC signatures. Red intensity tracks with similarity (`1 - cosine distance`).*


-----

**Visualize Mutational Signature Activities**


We can use the `msigPlot()` method also to visualize `mutSignExposures` objects 
(*e.g*., `blca_analysis$Results$exposures`, section 3.2, or 
`blca_deconv$Results$count.result`, section 3.3). A barplot (`ggplot` object) 
is returned. Each bar (x-axis) represents a cancer sample and the bar height 
(y-axis) indicates the total number of mutations. Stacked colors indicate 
the contribution of different mutational signatures to the total number 
of mutations in each sample. Additional arguments can be provided and 
are passed to the `plotSignExposures()` function; also, the plot can be 
further modified using standard  `ggplot2` functions. Here, we change the 
palette via the `scale_fill_manual()` function.


```{r}
actv_pal <- c('#ae017e', '#1d91c0', '#fa9fb5', '#41ab5d', '#fed976')
msigPlot(de_novo_activities,  top = 15) +
     		 scale_fill_manual(values = actv_pal)
```

*Barplot summarizing the activity of n=5 mutational signatures  that were de novo extracted from bladder cancer samples. A number of n=15 samples (with the highest mutation burden) are displayed.*

-----


**Exporting a mutSignExposures object as a data.frame object**

It is possible to export signature activity data via 
the `mutSignatures::as.data.frame()` method as shown below. 
Rows indicate mutational signatures and columns indicate samples. 
A transposed `data.frame` can be obtained by setting the argument 
`transpose = TRUE`.

```{r}
# Convert to data.frame
activ_df <- mutSignatures::as.data.frame(blca_activities, transpose = TRUE)

# Show excerpt
activ_df %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 9, full_width = FALSE)
```

-----
-----


## Additional Considerations


### 1. Minimum number of input samples



### 1. Deconvolution of mutation data using previously identified mutational signatures

The `mutSignatures` library is a flexible framework and supports deconvolution 
of mutation data using pre-defined mutational signatures (*e.g.,* COSMIC 
signatures, signatures that were identified before or by other groups). 
In this case, the pre-processing phase is virtually unchanged, but the NMF 
step is replaced by a fast combinatorial non-negative least-square
algorithm. This step is performed via the `resolveMutSignatures()` function. 
Results only include signature exposures (activities). 

The code below shows how to streamline all pre-processing steps 
(using `dplyr` pipes) and then execute the `resolveMutSignatures()` function.
Results are retrieved and used to generate a barplot summarizing signature 
exposures.


```{r results='asis'}
## Read VCF files in
##
vcf_ext <- 'vcf.gz'
deconv_fld <- 'VCF_deconv/'
my_vcfs <- grep(pattern = vcf_ext, dir(deconv_fld), value = TRUE)
my_vcfs <- paste0(deconv_fld, my_vcfs)

## Pre-processing + Counting (same as above) via dplyr pipes
##
blca_deco_counts <- mutSignatures::importVCFfiles(vcfFiles = my_vcfs) %>%
  
  dplyr::filter(QUAL >= 10) %>%
  mutate(SAMPLEID = sub('__simulated$', '', .$SAMPLEID)) %>%
  mutate(SAMPLEID = gsub('[[:punct:]]', '-', toupper(.$SAMPLEID))) %>%
  
  filterSNV(seq_colNames = c("REF", "ALT")) %>%
  
  attachContext(BSGenomeDb = BSgenome.Hsapiens.UCSC.hg19, 
                chr_colName = 'CHROM', start_colName = 'POS', 
                end_colName = 'POS', nucl_contextN = 3, 
                context_colName = 'context') %>%
  
  removeMismatchMut(refMut_colName = "REF", context_colName = "context",  
                    refMut_format = "N")    %>%
  
  attachMutType(ref_colName = "REF", var_colName = "ALT",              
                context_colName = "context") %>%
  
  countMutTypes(mutType_colName = 'mutType', sample_colName = 'SAMPLEID')

## Deconvolute using resolveMutSignatures()
##
blca_deco_analysis <- resolveMutSignatures(mutCountData = blca_deco_counts,
                                           signFreqData = de_novo_sigs,
                                           byFreq = TRUE)

## Fetch Results, Visualize Exposures
##

# Get results
blca_deco_expos <- blca_deco_analysis$Results$count.result

# Plot
my_pal <- c('#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854')
msigPlot(blca_deco_expos) + scale_fill_manual(values = my_pal)
```


Similar to what shown above, `mutSignExposures` objects can be
exported to `data.frame` using the `as.data.frame` method.

```{r}
## Export as data.frame
##
blca_deco_expos_df <- mutSignatures::as.data.frame(blca_deco_expos, 
                                                   transpose = TRUE)

# Show head
blca_deco_expos_df %>% 
  head(n = 12) %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 9, full_width = FALSE)
```

Notably, the output returned by `resolveMutSignatures()` includes two 
`mutSignExposures` objects:

- Total Mutation Counts by Signature in each sample: 
`[['Results']][['count.result']]` element (`mutSignExposures` object).

- Relative proportion of Signature activities (frequency) in each 
sample (sums up to unity): 
`[['Results']][['freq.result']]` element (`mutSignExposures` object).

Both results can be exported as `data.frame` and used in downstream analyses.
For example, here we fetch both objects, transform them in molten data.frames, 
bind them together, and use the resulting object to build a stacked 
signature exposure barplot (top panel, total counts by signature; bottom panel, 
proporion of counts by signature).


```{r}
## Downstream analyses and Advanced Visualization
##

# Export count version as well as freq.version as data.frames
blca_xp_cnt <- blca_deco_analysis$Results$count.result
blca_xp_cnt_df <- mutSignatures::as.data.frame(blca_xp_cnt, transpose = TRUE)

blca_xp_frq <- blca_deco_analysis$Results$freq.result
blca_xp_frq_df <- mutSignatures::as.data.frame(blca_xp_frq, transpose = TRUE)

# Transform TOT_counts exposure data.frame
tmp_df1 <- as.matrix(blca_xp_cnt_df) %>%
  reshape2:::melt.matrix(varnames = c('ID', 'Sign')) %>%
  mutate(panel = 'Abs Mut Counts')

# Transform FREQ exposure data.frame
tmp_df2 <- as.matrix(blca_xp_frq_df) %>%
  reshape2:::melt.matrix(varnames = c('ID', 'Sign')) %>%
  mutate(panel = 'Frequency')

# define sample order
sample_ord <- apply(blca_xp_cnt_df, 1, sum) %>% 
  sort(decreasing = TRUE) %>% names()

# Bind together
tmp <- rbind(tmp_df1, tmp_df2)  %>%
  mutate(ID = factor(.$ID, levels = sample_ord))

# Build barplot  
ggplot(tmp, aes(x = ID, y = value, fill = Sign)) +
  geom_bar(stat = 'identity', position = position_stack()) +
  theme_bw() +
  facet_grid(rows = vars(panel), scales = 'free', space = 'fixed') +
  ylab('Mutations') + xlab('') +
  scale_fill_manual('Signatures', values = my_pal) +
  theme(axis.text.x = element_text(angle = 60, size = 7, hjust = 1, vjust = 1), 
        legend.position = 'top')
```

-----



-----
-----


## Additional Considerations

Below, we included a list of comments and notes about specific steps of the 
analyses presented in this vignette. Attention should be paid to the following 
points as they are very important for a succesfull implementation of the
pipeline and interpretation of the results.


1. **Minimum number of input samples**. The minimum number of samples for performing *de novo* extraction of 
mutational signatures via the `decipherMutationalProcesses()` function
is n=2. Nevertheless, users may want to 
consider analyzing at least 10-15 samples (the more, the better).     

On the contrary, it is possible to attribute signature activities to any number 
of samples (n=1 or more) via the `resolveMutSignatures()` function.


```{r results='markup', eval=FALSE}
ex01 <- resolveMutSignatures(mutCountData = blca_counts[1], 
                             signFreqData = blca_cosmix)

ex01$Results$count.result
#>  MutSignature Exposures object - mutSignatures
#> 
#>  Total num of Samples: 1
#>  Total num of Signatures: 4  { first 4 signatures are displayed }
#>  Signature names:  COSMIC.1, COSMIC.2, COSMIC.5, COSMIC.13
#> 
#>     Sign.1   Sign.2   Sign.3   Sign.4
#>     ------   ------   ------   ------
#>   +     10       17        3       70  +  TCGA-A1-A0SI-01
#> 
```


-----

2. **Filtering mutations**. This pipeline is meant to analyze 
somatic mutations, and hence it is very important to 
filter out single nucleotide polymorphisms as 
well as other undesired variants (*e.g.*, germline mutations or 
technical artifacts). Filtering should be performed at the VCF stage or during 
pre-processing. Filtering approaches may include: *i)* excluding variants 
detected in a non-cancer sample from the same donor; *ii)* removing 
well-documented single nucleotide polymorphisms (for example, 
see <https://www.ncbi.nlm.nih.gov/snp/>); *iii)* excluding low-confidence 
mutations, variants with low PHRED scores, or variants with very-low 
variant-allele-frequency.  


-----



5. **Assure consistency of sequence names**. 
Even if VCF files and the BSGenome object were built using compatible 
genome references (*e.g.,* human `hg19`), it is possible that sequence names 
in the VCF files (*i.e.,* values in the `CHROM` column; 
for example `1`, `2`, `3`, ...) 
do NOT match the corresponding values stored in the `BSGenome` object 
(TYPICALLY, `chr1`, `chr2`, `chr3`, ...). Before running a signature 
analysis, please assure consistency of seqnames as shown below.

```{r comment='#', results='markup', eval=FALSE}
## Read VCF file
ex03 <- mutSignatures::importVCFfiles(vcfFiles = 'VCF_extra/example_01.vcf')
head(ex03)
#>   CHROM       POS ID REF ALT  QUAL FILTER INFO   SAMPLEID
#> 1     1  27057874  .   C   T 35.00      .    . example_01
#> 2     1  66081710  .   C   T 20.40      .    . example_01
#> 3     1 146756023  .   G   A 15.22      .    . example_01
#> 4     1 152082173  .   C   G 14.05      .    . example_01
#> 5     1 155237829  .   T   C 13.61      .    . example_01
#> 6     1 179782251  .   G   A 33.00      .    . example_01

## Access BSGenome seqnames
hg19 <- BSgenome.Hsapiens.UCSC.hg19
head(GenomeInfoDb::seqnames(hg19))
#> [1] "chr1" "chr2" "chr3" "chr4" "chr5" "chr6"

## Compare seqNames
sum(ex03$CHROM %in% seqnames(BSgenome.Hsapiens.UCSC.hg19)) / nrow(ex03)
#> 0

## Modify
ex03 <- ex03 %>%
  mutate(CHROM = paste0('chr', .$CHROM))

head(ex03)
#>   CHROM       POS ID REF ALT  QUAL FILTER INFO   SAMPLEID
#> 1  chr1  27057874  .   C   T 35.00      .    . example_01
#> 2  chr1  66081710  .   C   T 20.40      .    . example_01
#> 3  chr1 146756023  .   G   A 15.22      .    . example_01
#> 4  chr1 152082173  .   C   G 14.05      .    . example_01
#> 5  chr1 155237829  .   T   C 13.61      .    . example_01
#> 6  chr1 179782251  .   G   A 33.00      .    . example_01

sum(ex03$CHROM %in% seqnames(BSgenome.Hsapiens.UCSC.hg19)) / nrow(ex03)
#> 1
```




3. **Filtering samples**. We recommend excluding samples
with very low mutation burden from any mutational signature extraction or 
deconvolution job, since results may be inaccurate for these samples.
We typically exclude samples with a total number of SNVs smaller than 15-30 
(depending on the dataset). For example, in the analysis above, the sample with 
the smallest number of SNVs had n=17 SNVs.

```{r results='markup', eval=FALSE}
ex02 <- mutSignatures::as.data.frame(blca_counts) %>%
  t() %>% apply(MARGIN = 1, FUN = sum) %>% min()

ex02
#> [1] 17
```


4. **Assure consistency between VCF files and the BSGenome object**. Make sure 
that the same reference genome was used for read mapping as well as for 
the mutational signature analysis. In other words, it is not possible to 
run this pipeline using a human `hg19` reference if reads 
were mapped to human `hg38` or vice versa. 
If unsure about how the VCF files were generated, 
you may want to look at the VCF meta-information 
lines (these may include info about the reference genome and/or 
the lengths of chromosome sequences used for read mapping and 
variant calling). Based on that information, identify the most appropriate
annotation library 
(see <https://bioconductor.org/packages/release/data/annotation/>) 
to use in the analysis.


5. **Selecting the best number of signatures to extract**. Unfortunately, it is 
not always easy to select the best number of signatures to extract in a 
*de novo* signature analysis. The most appropriate number should be selected
based on the size of the dataset, the extent of inter-sample heterogeneity, 
preliminary information about similar cancer 
types (see <https://doi.org/10.1038/nature12477>), trial an 
error, evaluation of the mutational signature patterns 
(how similar / different are the profiles of *de novo*-extracted 
mutational signatures?), and stability results (silhouette plots). 
The `mutSignatures` library also 
provides a function to perform a preliminary assessment of the deconvolution
error (% of max error on the training set) 
with respect to the number of signatures being extracted. This function
may provide some insights into the optimal range of signature numbers 
to extract.


```{r results='asis', fig.width=5, fig.height=4.5, message=FALSE}
# prelimProcessAssess (this may take a while)
ex04 <- prelimProcessAssess(input = blca_counts, maxProcess = 10, plot = FALSE)

# Build a plot
ggplot(ex04, aes(x=numProcess, y=percentErr)) +
  geom_point() + geom_line() +
  scale_x_continuous(breaks = seq(1, 12, by = 1)) +
  theme_bw() + xlab('number of signatures') + ylab('% Error')
```

6. **Selecting the right number of bootstrap iterations**. 
Bootstrapping is an important step in the *de novo* signature extraction 
procedure, and contributes to assessing the stability of mutational signatures.
The number of bootstrap iterations affects both algorithm runtime as well as 
signature robustness. Users can set the total number of bootstrap iterations via 
the `num_totIterations` argument (`setMutClusterParams()` function). 
As a rule of thumb, we have used 50-100 iterations for quick testing
and 250-1000 iterations for production.


7. **Selecting the right set of signatures for a deconvolution analysis**. 
It is highly recommended to select relevant mutational signatures before
performing a mutational signature deconvolution analysis. 
In other words, we discourage
deconvoluting a catalog of mutations against the full set of n=30 COSMIC 
signatures, since this may identify signatures that
are NOT really active in that cancer type. Looking for published results 
from the same cancer type
(for example, see <https://doi.org/10.1038/nature12477>) and/or running 
a *de novo* signature 
extraction analysis may help to identify relevant signatures for a new dataset.


```{r eval=FALSE, results='markup'}
# Deconvolute BLCA via 
ex05 <- resolveMutSignatures(mutCountData = blca_deco_counts,
                             signFreqData = cosmix, byFreq = TRUE)

# Get signatures exposures (activities)
ex05_cnt <- ex05$Results$count.result

# Prevalent signatures by counts 
# Expected: COSMIC-1/2/5/13
# False negative: COSMIC-5 not identified!! 
# False positive: COSMIC-6 and COSMIC-3 were identified! 
mutSignatures::as.data.frame(ex05_cnt) %>%
  apply(MARGIN = 1, FUN = sum) %>% sort(decreasing = TRUE) %>%
  head()
#>  COSMIC.6 COSMIC.13  COSMIC.3  COSMIC.2  COSMIC.1 COSMIC.20 
#>  963.4687  868.1936  665.6782  580.4145  425.7910  340.2650 
```


8. **Parallelization**. Parallelization is supported on multi-core 
Linux and Unix environments (the feature was never tested on 
Windows machines). Parallelization 
can considerably speed up execution times of a *de novo* mutational signature 
extraction job (as long as the system has enough memory). To enable 
parallelization, it is sufficient to set the `num_parallelCores` argument 
(`setMutClusterParams()` function) to a value of 2 or higher.


9. **Working with non-standard mutation types**. All analyses presented
in this vignette used 3-nucleotide mutation types formatted according 
to the convention proposed by the Sanger Institute (*e.g.,* `A[C>A]G`).
However, the `mutSignatures` library is mutation-type-agnostinc. Users can 
define custom mutation types (*e.g.,* `C[G>T]T`, `GA[C>A]G` or `RR[Y>R]R`), 
count them using `countMutTypes()` and then analyze them using 
`decipherMutationalProcesses()` and `resolveMutSignatures()`. For more info, 
see our [2020 Sci.Rep. paper](https://doi.org/10.1038/s41598-020-75062-0) 
(figure 4).


-----

## Conclusions 

- We performed mutational signature analysis using a 
list of bladder cancer VCF files as input. 

  + A number of n=30 VCF files was used for *de novo* signature extraction.
  
  + A number of n=30 VCF files was used for signature deconvolution  (activity attribution).
  
- We described pre-processing steps to import data from VCF files, perform
filtering, retrieve 3-nucleotide genomic context, compile and count 
mutation types.

  + We also showed how to execute all these steps back-to-back via
  `dplyr` piping.
  
- We compared *de novo*-extracted mutational signatures to COSMIC signatures, 
exported results as `data.frame` and generated plots.

- Finally, we further discussed about additional 
points that should be kept in mind while designing and 
performing mutational signature analysis.

-----
-----

## SessionInfo

```{r results='markup', comment='#'}
# sessioninfo
sessionInfo()
```

Success!  ||  [Damiano Fantini](mailto:damiano.fantini@gmail.com), Joshua Meeks & the Meeks' Lab (Northwestern University, Chicago, IL)  ||  `r format(Sys.Date(), '%b %d, %Y')`



