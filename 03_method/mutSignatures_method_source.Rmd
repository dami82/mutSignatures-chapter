---
title: "Mutational Signature Analysis using mutSignatures"
author: "Damiano Fantini"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "asis", fig.align = "center", 
                      fig.width = 8, fig.height = 5, comment = '#', message = FALSE, 
                      warning = FALSE, fig.keep = "last")

# Load libs
#
library(mutSignatures)
library(dplyr)
library(ggplot2)
library(BSgenome.Hsapiens.UCSC.hg19)
library(kableExtra)

# Set working dir
#
#setwd('~/mutSignatures_chapter/03_method/')

# Set a seed
set.seed(12345)

# Set intermediate files
interm_01 <- 'interm_01.rds'
interm_02 <- 'interm_02.rds'
```


## The mutSignatures R pipeline

One of the hallmarks of cancer is the accumulation of somatic mutations. 
Exposure to carcinogens, DNA damage and 
inaccurate DNA repair may drive the formation of characteristic 
non-random patterns of DNA mutations, which are also known as 
**mutational signatures**.

There are several bioinformatic pipelines that allow analysis of mutational 
signatures. Here, we use the 
`mutSignatures` R library to perform such analysis. This library
was described in 
[Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0) 
and is available on *CRAN*, and on *GitHub* at the following URL:
<https://github.com/dami82/mutSignatures>. You can install the latest version 
(as of September 2022, ver `2.1.5`) of the library in your R environment using 
the `devtools` R package:

```
devtools::install_github("dami82/mutSignatures", force = TRUE, build_vignettes = TRUE)
```

Additional documentation to help getting started with the `mutSignatures` 
R library is available online (*1)* [CRAN vignette](https://cran.r-project.org/web/packages/mutSignatures/vignettes/get_sarted_with_mutSignatures.html); 
*2)* [Website](http://www.mutsignatures.org/); 
*3)* [Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0); and 
*4)* [corresponding Supplementary Materials](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7589488/bin/41598_2020_75062_MOESM1_ESM.pdf)).


-----

## Goal of the vignette

The goal of this vignette is to document all steps of a typical 
mutational signatures analysis performed using `mutSignatures`. 
A list of bladder cancer (BLCA) derived VCF files 
is used as input. These VCF files were generated
using unrestricted publicly available TCGA BLCA 
data ([input TCGA MAF available here](https://gdac.broadinstitute.org/runs/analyses__2016_01_28/reports/cancer/BRCA-TP/MutSigNozzleReport2CV/BRCA-TP.final_analysis_set.maf): data were downloaded, pre-processed, re-foprmatted, 
and saved as donor-specific VCF files (see
[GitHub mutSignatures-chapter Repo / build input files](https://github.com/dami82/mutSignatures-chapter/tree/main/02_build_input_files)).



The steps covered in the vignette include: 


1. Data import from bladder cancer VCF files and data pre-processing

2. *De novo* extraction of mutational signatures

3. Attribution of signature activity using previously identified mutational signatures

4. Results, visualization and data export


This vignette also includes additional comments and examples, focused on:


1. Streamlined pre-processing via `dplyr` pipes

2. Mutational signature activities: downstream analyses and advanced visualization

3. Selection of a suitable number of signatures to extract

4. Other Notes to successfully carry out mutational signature analyses




-----

### Acknowledgements

Joshua J Meeks (<joshua.meeks@northwestern.edu>), Khyati A Meghani (<khyati.meghani@northwestern.edu>).

-----


## Preparing the R environment, obtaining VCF files

This vignette is built using `R version 4.2.1` running under 
`Ubuntu 20.04.4 LTS`. The following R libraries are required: 
`mutSignatures`, `dplyr`, `ggplot2`, `BSgenome.Hsapiens.UCSC.hg19`, 
`httr`, and `kableExtra`.

VCF files (`*.vcf.gz`) were downloaded from the following GitHub repo:
<https://github.com/dami82/mutSignatures-chapter>. Contents of the
`02_build_input_files/VCF_de_novo` and `02_build_input_files/VCF_deconv` 
folders were read using the `httr` R library. 
The folder structure was re-created locally. 
These VCF files are used throughout the analysis 
for extracting and attributing mutational signatures. 


```{r results='markup', comment='#', message=FALSE}
# Load libs
library(mutSignatures)
library(dplyr)
library(ggplot2)
library(BSgenome.Hsapiens.UCSC.hg19)
library(kableExtra)

# GitHub URL, repo and subfolders
gh_raw_url <- 'https://github.com/dami82/mutSignatures-chapter/raw/main/02_build_input_files/'
gh_repo_url <- 'https://github.com/dami82/mutSignatures-chapter/tree/main/02_build_input_files/'
sub_fld_1 <- 'VCF_de_novo/'
sub_fld_2 <- 'VCF_deconv/'

# Initialize subfolders
try(unlink(sub_fld_1, recursive = TRUE), silent = TRUE)
dir.create(sub_fld_1)

try(unlink(sub_fld_2, recursive = TRUE), silent = TRUE)
dir.create(sub_fld_2)

# Read and download VCF files in sub_fld_1
tmp_req <- httr::GET(paste0(gh_repo_url, sub_fld_1))
tmp_cnt <- httr::content(tmp_req, as = 'text')
tmp_pos <- gregexpr(pattern = '>BLCA[[:digit:]]+\\.vcf\\.gz</a>', text = tmp_cnt)[[1]]
tmp_nms <- lapply(1:length(tmp_pos), function(i) {
  substr(x = tmp_cnt, start = tmp_pos[i] + 1, 
         stop = tmp_pos[i] + attributes(tmp_pos)$match.length[i] - 5)})

for (i in 1:length(tmp_nms)) {
  
  try(download.file(url = paste0(gh_raw_url, sub_fld_1, tmp_nms[[i]]), 
                    destfile = paste0(sub_fld_1, tmp_nms[[i]])), 
      silent = TRUE)
}

# Read and download VCF files in sub_fld_2
tmp_req <- httr::GET(paste0(gh_repo_url, sub_fld_2))
tmp_cnt <- httr::content(tmp_req, as = 'text')
tmp_pos <- gregexpr(pattern = '>BLCA[[:digit:]]+\\.vcf\\.gz</a>', text = tmp_cnt)[[1]]
tmp_nms <- lapply(1:length(tmp_pos), function(i) {
  substr(x = tmp_cnt, start = tmp_pos[i] + 1, 
         stop = tmp_pos[i] + attributes(tmp_pos)$match.length[i] - 5)})

for (i in 1:length(tmp_nms)) {
  
  try(download.file(url = paste0(gh_raw_url, sub_fld_2, tmp_nms[[i]]), 
                    destfile = paste0(sub_fld_2, tmp_nms[[i]])), 
      silent = TRUE)
}
```


-----



## Implementation


### 1. Data import from bladder cancer VCF files and data pre-processing {#section_preproc}


Data import and pre-processing is the first phase of this analysis. 
Often, mutation data are stored in **Variant Call Format (VCF)** 
files (for more info about the VCF specifications, 
see <http://samtools.github.io/hts-specs/>). The VCF data parsing and 
pre-processing involves 6 steps:  

1. VCF file data are parsed via the `importVCFfiles()` function, which returns an aggregated `data.frame`. 

2. The `filterSNV()` function removes INDELS and non-SNV mutations from the `data.frame`. 

3. Additional filtering and editing (optional). The user may want to remove variants with low Phred scores or edit *seqNames* (*i.e.,* chromosome names) or sample identifiers as needed.

4. Using the appropriate Reference `BSgenome` object, the `attachContext()` function retrieves the 3-nucleotide context at each SNV genomic position. 

5. The `removeMismatchMut()` function applies a final filter where SNVs are removed if mismatches are detected between expected and observed (reference) DNA sequences.  

6. Mutation types (*mutTypes*) are then computed for each SNV following the format proposed by the Sanger Institute (with pyrimidines as reference base) via the `attachMutType()` function.


The code shown below illustrates how to execute all data import and pre-processing steps.

```{r results='markup', comment='#'}
# import mutation data from a list of VCF files
vcf_ext <- 'vcf.gz'
de_novo_fld <- 'VCF_de_novo/'
my_vcfs <- grep(pattern = vcf_ext, dir(de_novo_fld), value = TRUE)
my_vcfs <- paste0(de_novo_fld, my_vcfs)
head(my_vcfs)
# Read a list of VCF files via importVCFfiles()
x <- importVCFfiles(vcfFiles = my_vcfs)

# Check data.frame dims
dim(x)
# Remove INDELS and non-SNV mutations
x <- filterSNV(dataSet = x,                     # input data.frame  
               seq_colNames = c("REF", "ALT"))  # columns w/ sequence data

# Check data.frame dims
dim(x)
# Optional filtering & editing
# (Recommendation) Use `dplyr`
x <- x %>%
  dplyr::filter(QUAL >= 10) 

# Check data.frame dims
dim(x)
# Attach 3-nt context
hg19 <- BSgenome.Hsapiens.UCSC.hg19
x <- attachContext(mutData = x,                  # input data.frame
                   BSGenomeDb = hg19,            # Reference Genome object
                   chr_colName = 'CHROM',        # seqNames column
                   start_colName = 'POS',        # genomic position column
                   end_colName = 'POS',          # for VCF files, same as above
                   nucl_contextN = 3,            # how large shall the context be
                   context_colName = 'context')  # name of the column being added

# Check data.frame dims
dim(x)
# Remove mismatches (positions whose VCF reference does not match the 
# corresponding genome sequence)
x <- removeMismatchMut(mutData = x,                  # input data.frame
                       refMut_colName = "REF",       # column name for ref base
                       context_colName = "context",  # column name for context
                       refMut_format = "N")          # reference format ('N')  

# Check data.frame dims
dim(x)
# Compute mutType (according to the standards proposed by the Sanger 
# Institute, i.e. with pyrimidines as reference base)
x <- attachMutType(mutData = x,                      # as above
                   ref_colName = "REF",              # column name for ref base
                   var_colName = "ALT",              # column name for mut base
                   context_colName = "context")      # context colname 

# Check data.frame dims
dim(x)
```


At the end of pre-processing phase, we obtain a `data.frame` where each row 
corresponds to a mutation. The `data.frame` includes two columns which are important 
for the downstream analyses: **1)** a column with sample identifiers 
(here, `SAMPLEID`); and **2)** a column with 
3-nucleotide mutation types (here, `mutType`). An excerpt of the `data.frame`
is shown below.


```{r results='asis'}
# Visualize head of the resulting data.frame
x %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 10, full_width = FALSE)
```


-----


### 2. *De novo* extraction of mutational signatures {#section_de_novo}


A *de novo* extraction of mutational signatures means performing 
non-negative matrix factorization (NMF) to identify patterns that can 
explain the distribution of somatic mutations observed across cancer samples. 

The `mutSignatures` R library supports Brunet's algorithm for NMF 
(described by [Brunet JP et al, 2004](https://doi.org/10.1073/pnas.0308531101)) 
as well as an alternative NMF algorithm (for more info see  
[Fantini D et al, 2020](https://doi.org/10.1038%2Fs41598-020-75062-0)).

A *de novo* extraction of mutational signatures involves 3 steps: 

1. count mutation types with respect to samples 
(via the `countMutTypes()` function and starting from the `data.frame` 
we prepared in [section 1](#section_preproc)

2. define a list of parameters for the analysis, including the number of signatures to 
extract, number of bootstrapping iteration, and number of cores to use 
(parallelization, optional)

3. perform NMF with bootstrapping via the `decipherMutationalProcesses()` function


The latter step can take several minutes / hours to complete, 
depending on the compute resources (amount of memory and number of cores), 
the size of the dataset and the complexity of the problem.


In this example, we extract `k=5` mutational signatures 
and perform 500 bootstrap iterations using the collection 
of somatic mutations compiled from the bladder cancer VCF data as input.

```{r results='markup', comment='#'}
# Count 3-nucleotide mutation types
blca_counts <- countMutTypes(mutTable = x, 
                             mutType_colName = 'mutType', 
                             sample_colName = 'SAMPLEID')

# Output
blca_counts
# Define parameters for the non-negative matrix factorization procedure.
blca_params <- setMutClusterParams( 
    num_processesToExtract = 5,       # num signatures to extract
    num_totIterations = 500,          # bootstrapping: usually 500-1000
    num_parallelCores = 1,            # num of cores (parallelization)
    seed = 12345)                     # random seed (optional) 
```


```{r results='hide', echo=FALSE, include=FALSE, eval=TRUE}
if (file.exists(interm_01)){
  blca_analysis <- readRDS(file = interm_01)  
} else {
  # De Novo Extraction of Mutational Signatures (may take a while)
  blca_analysis <- decipherMutationalProcesses(input = blca_counts,
                                               params = blca_params)  
  saveRDS(blca_analysis, file = interm_01, ascii = FALSE, compress = 'xz')
}
```
```{r eval=FALSE}
# De Novo Extraction of Mutational Signatures (may take a while)
blca_analysis <- decipherMutationalProcesses(input = blca_counts,
                                             params = blca_params)
```

At the end of the analysis, a silhouette plot is automatically built and
printed to the screen. It is also possible to re-build the plot using
`ggplot2` as shown below. 

```{r results='asis', fig.keep='last', fig.width=7.8, fig.height=7.2}
blca_silhouette <- blca_analysis$Supplementary$silhouette

sil_palette <- c('#DF536B', '#000000', '#2297E6', '#61D04F', '#28E2E5')
ggplot(blca_silhouette, aes(y = silhouette_value, x = id, fill = signature)) +
  geom_bar(stat = 'identity', width = 1) + ylim(c(-1, 1)) + 
  xlab('Iter. Results (by Group)') + ggtitle('Silhouette Plot') +
  scale_fill_manual(values = sil_palette) + 
  coord_flip() + theme_bw() +
  theme(plot.title = element_text(face = 'bold', hjust = 0.5))
```

*Silhouette plot showing robustness of the mutational signatures returned by the NMF analysis with bootstrapping.*


-----


Results (and intermediates) of a *de novo* signature extraction job are returned 
as elements of a `list` object. Specifically, output includes: 

- Mutational signatures: `[['Results']][['signatures']]` element 
(`mutationSignatures` object).

- Signature exposures (*i.e.* signature activities): 
`[['Results']][['exposures']]` element (`mutSignExposures` object).


These objects are further discussed in [section 4](#section_viz).


```{r results='markup'}
de_novo_sigs <- blca_analysis$Results$signatures
de_novo_activities <- blca_analysis$Results$exposures

# Show Signatures Object (output - I)
de_novo_sigs
```


-----




### 3. Deconvolution of mutation data using previously identified mutational signatures {#section_deconv}


The `mutSignatures` library also supports 
deconvolution of mutation data using previously identified mutational signatures 
(*e.g.,* COSMIC signatures or signatures that were 
identified as discussed in [section 2](#section_de_novo)).

The contribution (activity) of different mutational signatures in each sample 
is estimated via a fast combinatorial non-negative least-square
algorithm. This analysis is typically very fast, 
does not require parallelization, and
is carried out via the `resolveMutSignatures()` function. 

This type of analysis entails 3 steps: 

1. count mutation types with respect to samples 
(via the `countMutTypes()` function and starting from the `data.frame` 
we prepared in [section 1](#section_preproc))

2. retrieve a set of mutational signatures (`mutationSignatures` object)

3. resolve mutational signature activities via the 
`resolveMutSignatures()` function



In this example, we retrieve COSMIC signatures (version 2), 
subset bladder-related COSMIC signatures (*i.e.*, COSMIC-1, -2, -5, -13; 
see <https://doi.org/10.1038/nature12477>) 
and assign signature activities using the same collection 
of bladder cancer somatic mutations that were 
also used in the previous example.


```{r results='markup'}
# Count 3-nucleotide mutation types
blca_counts <- countMutTypes(mutTable = x, 
                             mutType_colName = 'mutType', 
                             sample_colName = 'SAMPLEID')

# Output
blca_counts
# Retrieve COSMIC signatures.
all_cosmic_v2 <- getCosmicSignatures()
blca_cosmic <- all_cosmic_v2[c(1, 2, 5, 13)]

# Output
blca_cosmic
# Resolve signature activities
blca_activ_analysis <- resolveMutSignatures(mutCountData = blca_counts, 
                                            signFreqData = blca_cosmic)
```




Results (and intermediates) of a signature activity attribution job are returned 
as elements of a `list` object.  Specifically, output includes: 

- Signature exposures (*i.e.* signature activities): 
`[['Results']][['count.result']]` element (`mutSignExposures` object).


This class of objects is further discussed in [section 4](#section_viz).

```{r results='markup'}
# Results
deconv_actv <- blca_activ_analysis$Results$count.result

# Show object
deconv_actv
```


-----




### 4. Results, visualization and data export {#section_viz}


**Visualize mutational signatures**


We can inspect the mutation profile of individual mutational
signatures that are included in a `mutationSignatures` object.
Examples include results of *de novo* extraction jobs (as shown above in 
[section 2](#section_de_novo)) or COSMIC signatures retrieved 
via the `getCosmicSignatures()` 
function (as shown above in [section 3](#section_deconv)).

The `msigPlot()` method can automatically build a barplot representing the
mutation profile of a signature of interest. The `signature` argument is used
to specify the numeric index of the signature of interest. Additional arguments 
(optional) are passed to the `plotMutTypeProfile()` function.

An example is shown below (using results from our the *de novo* signature 
extraction analysis).


```{r results='asis', fig.height=3.2, fig.width=12}
msigPlot(de_novo_sigs, signature = 2, ylim = c(0, 0.16), 
         main = 'BLCA signature (de novo) - #2')
```

*Barplot summarizing a mutational signature profile. Each bar indicates the frequency (y-axis) of a certain mutation type (x-axis) in the signature. Values are winsorized at 0.16 and 3-nucleotide mutation types are grouped and colored according to the corresponding SNV.*

-----


**Export mutationSignatures objects to `data.frame`**

A `mutationSignatures` object can be easily exported to `data.frame` using
either the `mutSignatures::as.data.frame()` method or the `coerceObj()` 
function. Each row is a mutation type, each colum is a signature. Values 
indicate the frequency of each mutation type in each mutation signature.
An example is shown below.


```{r results='asis'}
# Convert to data.frame
sigs_df <- mutSignatures::as.data.frame(de_novo_sigs)

# Show excerpt
sigs_df %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 10, full_width = FALSE)
```


-----

**Compare mutational signatures**

It is possible to perform a pairwise comparison across mutational signatures 
included in two `mutationSignatures` objects via the `matchSignatures()` 
function. 
Here we compare n=5 *de novo* extracted signatures from the bladder cancer 
samples to the n=4 COSMIC signatures previoulsy reported as prelavent in 
bladder cancer (COSMIC-1, -2, -5, -13). Results are visualized via a
heatmap chart where color intensity tracks with similarity (computed as 
`1 - cosine_distance`).

The plot shows that all but one of the n=5 *de novo* extracted signatures 
matched a corresponding BLCA COSMIC signature.


```{r results='asis', fig.height=4.2, fig.width=4.4}
# Match signatures
blca_new_vs_cosmic <- matchSignatures(de_novo_sigs, blca_cosmic)

# Show heatmap
blca_new_vs_cosmic$plot
```

*Heatmap showing similarity between bladder cancer de novo-extracted mutational signatures and n=4 COSMIC signatures. Red intensity tracks with similarity (`1 - cosine distance`).*


-----

**Visualize Mutational Signature Activities**


We can use the `msigPlot()` method also to visualize `mutSignExposures` objects 
(*e.g*., `blca_analysis$Results$exposures`, [section 2](#section_de_novo), or 
`blca_deconv$Results$count.result`, [section 3](#section_deconv)). 
A barplot (`ggplot` object) is returned. 
Each bar (x-axis) represents a cancer sample and the bar height 
(y-axis) indicates the total number of mutations. Stacked colors indicate 
the contribution of different mutational signatures to the total number 
of mutations in each sample. Additional arguments can be provided and 
are passed to the `plotSignExposures()` function; also, the plot can be 
further modified using standard  `ggplot2` functions. Here, we change the 
palette via the `scale_fill_manual()` function.


```{r fig.width=6.5}
my_pal <- c('#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854')
msigPlot(de_novo_activities,  top = 15) +
     		 scale_fill_manual(values = my_pal)
```

*Barplot summarizing the activity of n=5 mutational signatures  that were de novo extracted from bladder cancer samples. A number of n=15 samples (with the highest mutation burden) are displayed.*

-----


**Exporting a mutSignExposures object as a data.frame object**

It is possible to export signature activity data via 
the `mutSignatures::as.data.frame()` method as shown below. 
Rows indicate mutational signatures and columns indicate samples. 
A transposed `data.frame` can be obtained by setting the argument 
`transpose = TRUE`.

```{r}
# Convert to data.frame
activ_df <- mutSignatures::as.data.frame(de_novo_activities, transpose = TRUE)

# Show excerpt
activ_df %>% 
  head() %>% kable() %>% 
  kable_styling(bootstrap_options = "striped", font_size = 10, full_width = FALSE)
```

-----
-----


## Additional Examples



### 1. Streamlined Pre-processing via `dplyr` pipes

In the example below, we import and pre-process a list of VCF files as shown in 
[section 1](#section_preproc) and then we 
attribute signature activities using previously *de novo* 
identified BLCA mutational signatures.
This example illustrates 2 points: 

- streamlined pre-processing via `dplyr` pieps

- deconvolution using custom signatures (instead of COSMIC signatures)


```{r results='markup'}
## Prepare required objects
##
# BSgenome
hg19 <- BSgenome.Hsapiens.UCSC.hg19

# de novo signatures (see above)
de_novo_sigs
```
```{r results='asis'}
## Read VCF files in
##
vcf_ext <- 'vcf.gz'
deconv_fld <- 'VCF_deconv/'
my_vcfs <- grep(pattern = vcf_ext, dir(deconv_fld), value = TRUE)
my_vcfs <- paste0(deconv_fld, my_vcfs)

## Pre-processing + Counting (same as above) via dplyr pipes
##
deco_counts <- mutSignatures::importVCFfiles(vcfFiles = my_vcfs) %>%
  
  dplyr::filter(QUAL >= 10) %>%

  filterSNV(seq_colNames = c("REF", "ALT")) %>%
  
  attachContext(BSGenomeDb = hg19, 
                chr_colName = 'CHROM', start_colName = 'POS', 
                end_colName = 'POS', nucl_contextN = 3, 
                context_colName = 'context') %>%
  
  removeMismatchMut(refMut_colName = "REF", context_colName = "context",  
                    refMut_format = "N")    %>%
  
  attachMutType(ref_colName = "REF", var_colName = "ALT",              
                context_colName = "context") %>%
  
  countMutTypes(mutType_colName = 'mutType', sample_colName = 'SAMPLEID')

## Deconvolute using resolveMutSignatures()
##
deco_analysis <- resolveMutSignatures(mutCountData = deco_counts,
                                      signFreqData = de_novo_sigs,
                                      byFreq = TRUE)

## Fetch Results, Visualize Exposures
##

# Get results
deco_expos <- deco_analysis$Results$count.result

# Plot
my_pal <- c('#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854')
msigPlot(deco_expos, top = 30) + scale_fill_manual(values = my_pal)
```
*Barplot summarizing the activity of n=5 de novo extracted mutational signatures on an independent cohort of bladder cancer samples. All samples (n=30) are displayed.*

-----


### 2. Mutational Signature Activities: downstream analyses and Advanced Visualization

Attribution of mutational signatures via the `resolveMutSignatures()` function
returns two different `mutSignExposures` objects:

- `[['Results']][['count.result']]`: standard results which report the 'total' number of SNVs resulting from each signature (sample counts sum up to aprox. sample mutation burden)   

- `[['Results']][['freq.result']]`: frequency results which report the relative contribution of each signature (sample-specific values sum up to unity)

Frequencized results may be of interest in certain analyses / applications, 
since they provide an alternative view of the same results. In the 
example shown below, we aggregate `count` and `frequencized` results, and
build stacked barplots that provide better insights on bot mutation burden and 
signature activity for all samples in the dataset. 
The plot is built using `ggplot2`.


```{r}
## Downstream analyses and Advanced Visualization
##

# Export count version as well as freq.version as data.frames
blca_xp_cnt <- deco_analysis$Results$count.result
blca_xp_cnt_df <- mutSignatures::as.data.frame(blca_xp_cnt, transpose = TRUE)

blca_xp_frq <- deco_analysis$Results$freq.result
blca_xp_frq_df <- mutSignatures::as.data.frame(blca_xp_frq, transpose = TRUE)

# Transform TOT_counts exposure data.frame
tmp_df1 <- as.matrix(blca_xp_cnt_df) %>%
  reshape2:::melt.matrix(varnames = c('ID', 'Sign')) %>%
  mutate(panel = 'Abs Mut Counts')

# Transform FREQ exposure data.frame
tmp_df2 <- as.matrix(blca_xp_frq_df) %>%
  reshape2:::melt.matrix(varnames = c('ID', 'Sign')) %>%
  mutate(panel = 'Frequency')

# define sample order, relevel signatures
sample_ord <- apply(blca_xp_cnt_df, 1, sum) %>% 
  sort(decreasing = TRUE) %>% names()

# Bind together
tmp <- rbind(tmp_df1, tmp_df2)  %>%
  mutate(ID = factor(.$ID, levels = sample_ord), 
         Sign = factor(.$Sign, levels = rev(levels(.$Sign))))
  
# Build barplot  
ggplot(tmp, aes(x = ID, y = value, fill = Sign)) +
  geom_bar(stat = 'identity', position = position_stack()) +
  theme_bw() +
  facet_grid(rows = vars(panel), scales = 'free', space = 'fixed') +
  ylab('Mutations') + xlab('') +
  scale_fill_manual('Signatures', values = my_pal) +
  theme(axis.text.x = element_text(angle = 60, size = 7, hjust = 1, vjust = 1), 
        legend.position = 'top')
```

*Stacked barplots summarizing the activity of 5 de novo extracted mutational signatures on an independent cohort of bladder cancer samples. Top: total count results; bottom: frequencized results. All samples (n=30) are displayed.*

-----


### 3. Selecting a suitable number of signatures to extract


Unfortunately, selecting an optimal `k` number of signatures to (*de novo*) 
extract via `decipherMutationalProcesses()` is no trivial task. 
We encourage the user to proceed by trial and error, *i.e.* testing a range of 
`k` values,  evaluating the results from each iteration and then selecting the
`k` value with the most robust QC results. 

- The range of `k` vaules can be selected based on previous analyses, published reports (*e.g.*, see <https://doi.org/10.1038/nature12477>) as well as the `prelimProcessAssess()` function

- At each iteration, the user may want to inspect: 

  + how similar / different are the profiles of *de novo*-extracted mutational signatures
  
  + stability results (silhouette plots).
  
The goal is to identify the largest `k` returning robust silhouettes for all signatures / clusters as well as signatures whose profiles are NOT (largely) overlapping. 
The example below shows how we selected an appropriate number `k` of 
signatures in the analysis performed in  [section 2](#section_de_novo).


**Part 1 | Selecting a range of `k` values**

First, we perform a preliminary assessment of the relationship between 
deconvolution error and number of signatures being extracted 
via the `prelimProcessAssess()` function.
The results suggest that n=3 signatures are required to explain most of the signal.
The drop in error continues for larger `k` values, but the incremental drop in % error is small.
Based on these results, we decided to test the range of `k` values `k=3` to `k=6`.


```{r results='asis', fig.height=4, fig.width=6}
# prelimProcessAssess (this may take a while)
test <- prelimProcessAssess(input = blca_counts, maxProcess = 10, plot = FALSE)

# Build a plot
ggplot(test, aes(x=numProcess, y=percentErr)) +
  geom_point() + geom_line() +
  scale_x_continuous(breaks = seq(1, 12, by = 1)) +
  theme_bw() + xlab('number of signatures') + ylab('% Error')
```

*xy-scatter plot showing the % error (% of max error) with respect to the number of signatures* 



-----


**Part 2 | Iterate through the range of `k` values**

For each value in the selected range of `k` values, 
we performed *de novo* signature extraction. 
For these analyses we kept the total number of bootstrap iterations 
relatively small (*e.g., `num_totIterations = 50`). At the end of each cycle, 
we saved the following items for further inspection:

- silhouette data (to rebuild and inspect silhouette plots)

- *de novo* signatures (inspect mutational signature profiles; assess similarity)

```{r fig.keep='none', results='hide', include=FALSE, echo=FALSE, eval=TRUE}
# num bootstrap iterations
boot_i <- 50

# initialize k seq and collector
k_range <- seq(3, 6, by=1)
k_res <- list()

if (file.exists(interm_02)){
  k_res <- readRDS(interm_02)
} else {
  for (ki in k_range) {

    # set params (ki)
    tmp_par <- setMutClusterParams(
      num_processesToExtract = ki, num_totIterations = boot_i)
    
    # run analysis (ki iteration)
    tmp_res <- decipherMutationalProcesses(blca_counts, params = tmp_par)
    
    # save results (list)
    k_res[[paste0('k=', ki)]] <- list (
      signatures = tmp_res$Results$signatures, 
      silhouette = tmp_res$Supplementary$silhouette
    )
  }
  saveRDS(object = k_res, file = interm_02, ascii = FALSE, compress = 'xz')
}
```
```{r fig.keep='none', results='hide', eval=FALSE}
# num bootstrap iterations
boot_i <- 50

# initialize k seq and collector
k_range <- seq(3, 6, by=1)
k_res <- list()

for (ki in k_range) {

  # set params (ki)
  tmp_par <- setMutClusterParams(
    num_processesToExtract = ki, num_totIterations = boot_i)
  
  # run analysis (ki iteration)
  tmp_res <- decipherMutationalProcesses(blca_counts, params = tmp_par)
  
  # save results (list)
  k_res[[paste0('k=', ki)]] <- list (
    signatures = tmp_res$Results$signatures, 
    silhouette = tmp_res$Supplementary$silhouette
  )
}
```


-----



**Part 2a | `k` too small** (`k=3`)

The results from `k=3` show that all clusters have a reasonably robust silhouette profile, and the heatmap reveals no overlap between *de novo* extracted signatures. While there is nothing wrong with these results, our goal should be to identify the largest `k` returning solid, consistent results.   


```{r results='asis', fig.keep='last', fig.width=8, fig.height=3.4}
## retrieve k=3 iteration results
k3_sig <- k_res$`k=3`$signatures
k3_silh <- k_res$`k=3`$silhouette
k3_match <- matchSignatures(k3_sig, k3_sig)
k3_heatmap <- k3_match$plot

# build silhouette plot
sil_palette <- c('#DF536B', '#000000', '#2297E6', '#61D04F', '#28E2E5', '#FF7F00')
k3_sil <- ggplot(k3_silh, aes(y = silhouette_value, x = id, fill = signature)) +
  geom_bar(stat = 'identity', width = 1) + ylim(c(-1, 1)) + 
  xlab('Iter. Results (by Group)') +
  scale_fill_manual(values = sil_palette) + 
  coord_flip() + theme_bw() + theme(legend.position = 'none') 

# Show
gridExtra::grid.arrange(k3_sil, k3_heatmap, ncol = 2)
```


*Results from the `k=3` iteration. Left: silhouette plot showing robustness of bootstrap clusters corresponding to different mutational signatures; right: heatmap summarizing pairwise similarity across signatures (de novo extracted signatures vs. self).*


-----



**Part 2b | `k` too large** (`k=6`)

The results from `k=6` show that some clusters have inconsistent silhouette profiles; also, the heatmap reveals a certain overlap between selected signatures (especially, signatures `05` and `06`).    


```{r results='asis', fig.keep='last', fig.width=12, fig.height=5}
## retrieve k=6 iteration results
k6_sig <- k_res$`k=6`$signatures
k6_silh <- k_res$`k=6`$silhouette
k6_match <- matchSignatures(k6_sig, k6_sig)
k6_heatmap <- k6_match$plot

# build silhouette plot
k6_sil <- ggplot(k6_silh, aes(y = silhouette_value, x = id, fill = signature)) +
  geom_bar(stat = 'identity', width = 1) + ylim(c(-1, 1)) + 
  xlab('Iter. Results (by Group)') +
  scale_fill_manual(values = sil_palette) + 
  coord_flip() + theme_bw() + theme(legend.position = 'none') 

# Show
gridExtra::grid.arrange(k6_sil, k6_heatmap, ncol = 2)
```


*Results from the `k=6` iteration. Left: silhouette plot showing robustness of bootstrap clusters corresponding to different mutational signatures; right: heatmap summarizing pairwise similarity across signatures (de novo extracted signatures vs. self).*

-----

A closer look at mutational profiles confirmed the similarity between signatures `05` and `06`. All these observations point to the need of selecting a smaller `k`.


```{r results='asis', fig.height=6, fig.width=12}
par(mfrow = c(2, 1))
msigPlot(k6_sig, signature = 5, ylim = c(0, 0.15))
msigPlot(k6_sig, signature = 6, ylim = c(0, 0.15))
```


*Barplots summarizing mutational signature profiles. Each bar indicates the frequency (y-axis) of a certain mutation type (x-axis) in the signature. Values are winsorized at 0.16 and 3-nucleotide mutation types are grouped and colored according to the corresponding SNV.*



-----



**Part 2c | `k` about right** (`k=5`)


Our analysis converged on `k=5` as the most appropriate value. We selected this value because this is the largest `k` value returning strong silhouette profiles and a list of non-overlapping signatures (low pairwise similarity in the *vs. self* analysis, except for the identity). 


```{r results='asis', fig.keep='last', fig.width=10.8, fig.height=4.6}
## retrieve k=5 iteration results
k5_sig <- k_res$`k=5`$signatures
k5_silh <- k_res$`k=5`$silhouette
k5_match <- matchSignatures(k5_sig, k5_sig)
k5_heatmap <- k5_match$plot

# build silhouette plot
k5_sil <- ggplot(k5_silh, aes(y = silhouette_value, x = id, fill = signature)) +
  geom_bar(stat = 'identity', width = 1) + ylim(c(-1, 1)) + 
  xlab('Iter. Results (by Group)') +
  scale_fill_manual(values = sil_palette) + 
  coord_flip() + theme_bw() + theme(legend.position = 'none') 

# Show
gridExtra::grid.arrange(k5_sil, k5_heatmap, ncol = 2)
```


*Results from the `k=6` iteration. Left: silhouette plot showing robustness of bootstrap clusters corresponding to different mutational signatures; right: heatmap summarizing pairwise similarity across signatures (de novo extracted signatures vs. self).*




-----
-----


## Other Notes to successfully carry out mutational signature analyses

Below, we included a list of comments and notes about specific steps of the 
analyses presented in this vignette. Attention should be paid to the following 
points as they are very important for a succesfull implementation of the
pipeline and interpretation of the results.


- **Minimum number of input samples**. The minimum number of samples for performing *de novo* extraction of 
mutational signatures via the `decipherMutationalProcesses()` function
is n=2. Nevertheless, users may want to 
consider analyzing at least 10-15 samples (the more, the better). 
On the contrary, it is possible to attribute signature activities to any number 
of samples (n=1 or more) via the `resolveMutSignatures()` function.


```{r results='markup', eval=TRUE}
ex01 <- resolveMutSignatures(mutCountData = blca_counts[1], 
                             signFreqData = blca_cosmic)

ex01$Results$count.result
```


-----

- **Filtering mutations**. This pipeline is meant to analyze 
somatic mutations, and hence it is very important to 
filter out single nucleotide polymorphisms as 
well as other undesired variants (*e.g.*, germline mutations or 
technical artifacts). Filtering should be performed at the VCF stage or during 
pre-processing. Filtering approaches may include: *i)* excluding variants 
detected in a non-cancer sample from the same donor; *ii)* removing 
well-documented single nucleotide polymorphisms (for example, 
see <https://www.ncbi.nlm.nih.gov/snp/>); *iii)* excluding low-confidence 
mutations, variants with low PHRED scores, or variants with very-low 
variant-allele-frequency.  


-----



- **Assure consistency of sequence names**. 
Even if VCF files and the `BSGenome` object were built using compatible 
genome references (*e.g.,* human `hg19`), it is possible that sequence names 
in the VCF files (*i.e.,* values in the `CHROM` column; 
for example `1`, `2`, `3`, ...) 
do NOT match the corresponding values stored in the `BSGenome` object 
(TYPICALLY, `chr1`, `chr2`, `chr3`, ...). Before running a signature 
analysis, please assure consistency of seqnames as shown below.

```{r comment='#', results='markup', eval=FALSE}
## Get & Read VCF file
my_vcf_url <- paste0(gh_raw_url, 'VCF_extra/BLCA2014.vcf.gz')
tmp_vcf <- 'BLCA2014.vcf.gz'
download.file(url = my_vcf_url, destfile = tmp_vcf)
ex02 <- mutSignatures::importVCFfiles(vcfFiles = tmp_vcf)

# Show header of CHROM
head(ex02$CHROM, 12)
## Access BSGenome seqnames
hg19 <- BSgenome.Hsapiens.UCSC.hg19
head(GenomeInfoDb::seqnames(hg19), 12)
## Compare seqNames
## Expected: 1; observed: 0!!!
sum(ex02$CHROM %in% seqnames(hg19)) / nrow(ex02)

## Modify
ex02 <- ex02 %>%
  mutate(CHROM = paste0('chr', .$CHROM))

# Show header of CHROM
head(ex02$CHROM)
## Compare seqNames
## Expected: 1; observed: 1!!! Success!
sum(ex02$CHROM %in% seqnames(hg19)) / nrow(ex02)
```


-----


- **Assure consistency between VCF files and the BSGenome object**. Make sure 
that the same reference genome was used for read mapping as well as for 
the mutational signature analysis. In other words, it is NOT possible to 
run this pipeline using a human `hg19` reference if reads 
were mapped to human `hg38` or vice versa. Users should
identify the most appropriate annotation library 
(see <https://bioconductor.org/packages/release/data/annotation/>) 
to use in the analysis.


-----



- **Filtering samples**. We recommend excluding samples
with very low mutation burden from any mutational signature extraction or 
deconvolution job, since results may be inaccurate for these samples.
We typically exclude samples with a total number of SNVs smaller than 15-30 
(depending on the dataset). For example, in the example below we filter a
`mutationCounts` object to only retain samples with at least n=30 SNVs.

```{r results='markup'}
## Min count in blca_counts
blca_counts %>%
  mutSignatures::as.data.frame() %>%
  apply(MARGIN = 2, FUN = sum) %>%
  min()
## Filtering out samples with less than 30 SNVs
## from a `mutationCounts` object
keep <- blca_counts %>%
  mutSignatures::as.data.frame() %>%
  apply(MARGIN = 2, FUN = sum) %>%
  {which(. >= 30)} %>% as.numeric()

flt_counts <- blca_counts[keep]

# check min counts in flt_counts
flt_counts %>%
  mutSignatures::as.data.frame() %>%
  apply(MARGIN = 2, FUN = sum) %>%
  min()
```


-----


- **Selecting the right number of bootstrap iterations**. 
The number of bootstrap iterations affects both algorithm runtime as well as 
signature robustness. Users can set the total number of bootstrap iterations via 
the `num_totIterations` argument (`setMutClusterParams()` function). 
We have used 50-100 iterations for quick testing
and 250-1000 iterations for production.


-----


- **Selecting the right set of signatures for a deconvolution analysis**. 
It is highly recommended to select relevant mutational signatures before
performing a mutational signature deconvolution analysis via `resolveMutSignatures()`. 


-----


- **Parallelization**. Parallelization is fully supported on multi-core 
Linux and Unix environments. Parallelization 
can considerably speed up execution times of a *de novo* mutational signature 
extraction job (as long as the system has enough memory). To enable 
parallelization, it is sufficient to set the `num_parallelCores` argument 
(`setMutClusterParams()` function) to a value of 2 or higher.


-----


- **Working with non-standard mutation types**. All analyses presented
in this vignette used 3-nucleotide mutation types formatted according 
to the convention proposed by the Sanger Institute (*e.g.,* `A[C>A]G`).
However, the `mutSignatures` library is mutation-type-agnostinc. Users can 
define custom mutation types (*e.g.,* `C[G>T]T`, `GA[C>A]G` or `RR[Y>R]R`), 
count them using `countMutTypes()` and then analyze them using 
`decipherMutationalProcesses()` and `resolveMutSignatures()`. For more info, 
see our [2020 Sci.Rep. paper](https://doi.org/10.1038/s41598-020-75062-0) 
(figure 4).


-----
-----



## Conclusions 

- We described all steps included in a mutational signature analysis

- We imported mutations from a list of bladder cancer VCF files

  + data were imported, pre-processed, and 3-nucleotide mutation types were computed

- We *de novo* extracted 5 mutational signatures and inspected the resulting silhouette plots
  
- We estimated the activity of COSMIC mutational signatures (COSMIC-1, -2, -5, and -13) as well as custom signatures in a list of bladder cancer samples
  
- We built plots and visualizations (via `mutSignature` methods as well as `ggplot2`), and exported results for custom processing
  
- Finally, we discussed several points to successfully carry out mutational signature analysis using real world data.



-----
-----

## SessionInfo

```{r results='markup', comment='#'}
# sessioninfo
sessionInfo()
```

Success!  ||  [Damiano Fantini](mailto:damiano.fantini@gmail.com), Joshua Meeks & the Meeks' Lab (Northwestern University, Chicago, IL)  ||  `r format(Sys.Date(), '%b %d, %Y')`



